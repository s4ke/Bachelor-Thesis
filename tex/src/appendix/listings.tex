\section*{Listings}

\lstset{language=java}
\begin{lstlisting}[frame=htrbl, caption={the simple Transaction contract}, label={lst:Transaction.java}]
public class Transaction implements TransactionContext {

	private boolean progress = true;
	private List<Synchronization> syncs = new ArrayList<>();
	
	@Override
	public boolean isTransactionInProgress() {
		return this.progress;
	}
	
	@Override
	public Object getTransactionIdentifier() {
		return this;
	}
	
	@Override
	public void registerSynchronization(
		Synchronization synchronization ) {
		this.syncs.add( synchronization );
	}
	
	/**
	 * @throws IllegalStateException if already commited/rolledback
	 */
	public void commit() {
		if ( !this.progress ) {
			throw new IllegalStateException( 
			"can't commit - " + 
			"No Search Transaction is in Progress!" );
		}
		this.progress = false;
		this.syncs.forEach( Synchronization::beforeCompletion );
		
		for ( Synchronization sync : this.syncs ) {
			sync.afterCompletion( Status.STATUS_COMMITTED );
		}
	}
	
	/**
	 * @throws IllegalStateException if already commited/rolledback
 	 */
	public void rollback() {
		if ( !this.progress ) {
			throw new IllegalStateException( 
			"can't rollback - " + 
			"No Search Transaction is in Progress!" );
		}
		this.progress = false;
		this.syncs.forEach( Synchronization::beforeCompletion );
	
		for ( Synchronization sync : this.syncs ) {
			sync.afterCompletion( Status.STATUS_ROLLEDBACK );
		}
	}

}
\end{lstlisting}

\begin{lstlisting}[frame=htrbl, caption={StandaloneSearchConfiguration.java}, label={lst:StandaloneSearchConfiguration.java}]
/**
 * Manually defines the configuration. 
 * Classes and properties are the only implemented options at the moment.
 *
 * @author Martin Braun (adaption), Emmanuel Bernard
 */
public class StandaloneSearchConfiguration 
	extends SearchConfigurationBase 
	implements SearchConfiguration {

	private final Logger LOGGER = 
		Logger.getLogger( 
			StandaloneSearchConfiguration.class.getName() 
		);
		
	private final Map<String, Class<?>> classes;
	private final Properties properties;
	private final HashMap<Class<? extends Service>, Object> 
		providedServices;
	private final InstanceInitializer initializer;
	private SearchMapping programmaticMapping;
	private boolean transactionsExpected = true;
	private boolean indexMetadataComplete = true;
	private boolean idProvidedImplicit = false;
	private ClassLoaderService classLoaderService;
	private ReflectionManager reflectionManager;

	public StandaloneSearchConfiguration() {
		this( new Properties() );
	}

	public StandaloneSearchConfiguration(Properties properties) {
		this( 
			SubClassSupportInstanceInitializer.INSTANCE, 
			properties
		);
	}

	public StandaloneSearchConfiguration(InstanceInitializer init) {
		this( new Properties() );
	}

	public StandaloneSearchConfiguration(InstanceInitializer init, 
		Properties properties) {
		this.initializer = init;
		this.classes = new HashMap<>();
		this.properties = properties;
		// default values if nothing was explicitly set
		this.properties.computeIfAbsent(
			"hibernate.search.default.directory_provider", 
			(key) -> {
				LOGGER.info( 
				  "defaulting to RAM directory-provider" 
				);
			return "ram";
		});
		this.properties.computeIfAbsent(
			"hibernate.search.lucene_version", 
			(key) -> {
				LOGGER.info( 
					"defaulting to Lucene Version: " 
					+ Version.LUCENE_4_10_4.toString() 
				);
				return Version.LUCENE_4_10_4.toString();
		});
		this.reflectionManager = new JavaReflectionManager();
		this.providedServices = new HashMap<>();
		this.classLoaderService = new DefaultClassLoaderService();
	}

	public StandaloneSearchConfiguration addProperty(String key,
		String value) {
		properties.setProperty( key, value );
		return this;
	}

	public StandaloneSearchConfiguration addClass(Class<?> indexed) {
		classes.put( indexed.getName(), indexed );
		return this;
	}

	@Override
	public Iterator<Class<?>> getClassMappings() {
		return classes.values().iterator();
	}

	@Override
	public Class<?> getClassMapping(String name) {
		return classes.get( name );
	}

	@Override
	public String getProperty(String propertyName) {
		return properties.getProperty( propertyName );
	}

	@Override
	public Properties getProperties() {
		return properties;
	}

	@Override
	public ReflectionManager getReflectionManager() {
		return this.reflectionManager;
	}

	@Override
	public SearchMapping getProgrammaticMapping() {
		return programmaticMapping;
	}

	public StandaloneSearchConfiguration setProgrammaticMapping(
			SearchMapping programmaticMapping
		) {
		this.programmaticMapping = programmaticMapping;
		return this;
	}

	@Override
	public Map<Class<? extends Service>, Object> 
		getProvidedServices() {
		return providedServices;
	}

	public void addProvidedService(
			Class<? extends Service> serviceRole,
			Object service
		) {
		providedServices.put( serviceRole, service );
	}

	@Override
	public boolean isTransactionManagerExpected() {
		return this.transactionsExpected;
	}

	public void setTransactionsExpected(
			boolean transactionsExpected) {
		this.transactionsExpected = transactionsExpected;
	}

	@Override
	public InstanceInitializer getInstanceInitializer() {
		return initializer;
	}

	@Override
	public boolean isIndexMetadataComplete() {
		return indexMetadataComplete;
	}

	public void setIndexMetadataComplete(
		boolean indexMetadataComplete) {
		this.indexMetadataComplete = indexMetadataComplete;
	}

	@Override
	public boolean isIdProvidedImplicit() {
		return idProvidedImplicit;
	}

	public StandaloneSearchConfiguration 
		setIdProvidedImplicit(boolean idProvidedImplicit) {
		this.idProvidedImplicit = idProvidedImplicit;
		return this;
	}

	@Override
	public ClassLoaderService getClassLoaderService() {
		return classLoaderService;
	}

	public void setClassLoaderService(
		ClassLoaderService ) {
		this.classLoaderService = classLoaderService;
	}

}
\end{lstlisting}

\begin{lstlisting}[frame=htrbl, caption={BasicEntityProvider.java}, label={lst:BasicEntityProvider.java}]
public class BasicEntityProvider implements EntityProvider {

	private static final String QUERY_FORMAT = 
		"SELECT obj FROM %s obj " +
		"WHERE obj.%s IN :ids";
	private final EntityManager em;
	private final Map<Class<?>, String> idProperties;

	public BasicEntityProvider(EntityManager em,
		Map<Class<?>, String> idProperties) {
		this.em = em;
		this.idProperties = idProperties;
	}

	@Override
	public void close() throws IOException {
		this.em.close();
	}

	@Override
	public Object get(Class<?> entityClass, Object id,
		Map<String, String> hints) {
		return this.em.find( entityClass, id );
	}

	@SuppressWarnings({"rawtypes", "unchecked"})
	@Override
	public List getBatch(Class<?> entityClass, List<Object> ids,
		Map<String, String> hints) {
		List<Object> ret = new ArrayList<>( ids.size() );
		if ( ids.size() > 0 ) {
			String idProperty = 
				this.idProperties.get( entityClass );
			String queryString = 
				String.format(
					QUERY_FORMAT,
					this.em.getMetamodel()
						.entity( entityClass )
						.getName(),
					idProperty
		);
		Query query = this.em.createQuery( queryString );
		query.setParameter( "ids", ids );
			ret.addAll( query.getResultList() );
		}
		return ret;
	}
	
	public void clearEm() {
		this.em.clear();
	}

	public EntityManager getEm() {
		return this.em;
	}

}
\end{lstlisting}

\begin{lstlisting}[frame=htrbl, caption={Obtaining idProperties}, label={lst:idProperties.java}]
SearchConfiguration config = ...;

MetadataProvider metadataProvider = 
	MetadataUtil.getDummyMetadataProvider( config );
MetadataRehasher rehasher = new MetadataRehasher();

List<RehashedTypeMetadata> rehashedTypeMetadatas = new ArrayList<>();
for ( Class<?> indexRootType : this.getIndexRootTypes() ) {
	RehashedTypeMetadata rehashed = 
		rehasher.rehash( 
			metadataProvider
				.getTypeMetadataFor( indexRootType ) 
		);
	rehashedTypeMetadatas.add( rehashed );
}

Map<Class<?>, String> idProperties = 
	MetadataUtil.calculateIdProperties( rehashedTypeMetadatas );
\end{lstlisting}

\begin{lstlisting}[frame=htrbl, caption={generic JPA FullTextEntityManager}, label={lst:FullTextEntityManager.java_generic}]
/**
 * @author Emmanuel Bernard
 * @author Martin Braun
 */
public interface FullTextEntityManager extends EntityManager {
	
	/**
	 * Create a fulltext query on top of a native Lucene
	 * query returning the matching objects of columnTypes
	 * <code>entities</code> and their respective subclasses.
	 *
	 * @param luceneQuery The native Lucene query to be 
	 *		run against the Lucene index.
	 * @param entities List of classes for columnTypes filtering.
	 *		The query result will only return entities 
	 *		of the specified types and their respective
	 *		subtype. 
	 *		If no class is specified no columnTypes filtering
	 *		will take place.
	 *
	 * @return A <code>FullTextQuery</code> wrapping around the
	 *	native Lucene query.
	 *
	 * @throws IllegalArgumentException if entityType is 
	 * <code>null</code> or not a class or superclass annotated with
	 * <code>@Indexed</code>.
	 */
	FullTextQuery createFullTextQuery(
		org.apache.lucene.search.Query luceneQuery,
		Class<?>... entities);
	
	/**
	 * Force the (re)indexing of a given <b>managed</b> object.
	 * Indexation is batched per search-transaction: if a
	 * transaction is active, the operation will not affect
	 * the index at least until commit.
	 *
	 * @param entity The entity to index
	 *	- must not be <code>null</code>.
	 *
	 * @throws IllegalArgumentException
	 *	if entity is null or not an @Indexed entity
	 * @throws IllegalStateException
	 *	if no search-transaction is in progress
	 */
	<T> void index(T entity);
	
	/**
	 * @return the <code>SearchFactory</code> instance.
	 */
	SearchFactory getSearchFactory();
	
	/**
	 * Remove the entity with the columnTypes 
	 * <code>entityType</code> and the identifier
	 * <code>id</code> from the index. If
	 * <code>id == null</code> all indexed entities
	 * of this columnTypes and its indexed subclasses
	 * are deleted. In this case
	 * this method behaves like {@link #purgeAll(Class)}.
	 *
	 * @param entityType The columnTypes of the 
	 *	entity to delete.
	 * @param id The id of the entity to delete.
	 *
	 * @throws IllegalArgumentException if entityType is 
	 * <code>null</code> or not a class or superclass 
	 * annotated with <code>@Indexed</code>.
	 * @throws IllegalStateException if no 
	 * search-transaction is in progress
	 */
	<T> void purge(Class<T> entityType, Serializable id);
	
	/**
	 * Remove all entities from of particular class
	 * and all its subclasses from the  index.
	 *
	 * @param entityType The class of the entities to remove.
	 *
	 * @throws IllegalArgumentException if entityType is 
	 *	<code>null</code> or not a class or superclass 
	 * annotated with <code>@Indexed</code>.
	 * @throws IllegalStateException if no search-transaction
	 * is in progress
	 */
	<T> void purgeAll(Class<T> entityType);
	
	<T> void purgeByTerm(Class<T> entityType,
		String field,
		Integer val);
	
	<T> void purgeByTerm(Class<T> entityType,
		String field,
		Long val);
	
	<T> void purgeByTerm(Class<T> entityType,
		String field,
		Float val);
	
	<T> void purgeByTerm(Class<T> entityType,
		String field,
		Double val);
	
	<T> void purgeByTerm(Class<T> entityType,
		String field,
		String val);
	
	/**
	 * Flush all index changes forcing Hibernate Search to apply all
	 * changes to the index not waiting for the batch limit.
	 *
	 * @throws IllegalStateException
	 *	if no search-transaction is in progress
	 */
	void flushToIndexes();
	
	/**
	 * <b>different from the original Hibernate Search!</b> <br>
	 * <br>
	 * this has to be called when you want to 
	 * change the index manually!
	 *
	 * @throws IllegalStateException 
	 *	if a search-transaction is already in progress
	 */
	void beginSearchTransaction();
	
	/**
	 * <b>different from the original Hibernate Search!</b> <br>
	 * <br>
	 * this has to be called when you want to 
	 * change the index manually!
	 *
	 * @throws IllegalStateException
	 *	if no search-transaction is in progress
	 */
	void rollbackSearchTransaction();
	
	/**
	 * <b>different from the original Hibernate Search!</b> <br>
	 * <br>
	 * this has to be called when you want to 
	 * change the index manually!
	 *
	 * @throws IllegalStateException
	 *	if no search-transaction is in progress
	 */
	void commitSearchTransaction();
	
	boolean isSearchTransactionInProgress();
	
	/**
	 * @throws IllegalStateException
	 *	if search-transaction is still in progress.
	 *	underlying EntityManager is still closed.
	 */
	void close();
	
	/**
	 * Creates a MassIndexer to rebuild the indexes of some
	 * or all indexed entity types. Instances cannot be reused. Any
	 * {@link org.hibernate.search.indexes.interceptor
	 *	.EntityIndexingInterceptor} registered on the entity 
	 * types are applied: each instance will trigger an
	 * {@link org.hibernate.search.indexes.interceptor
	 *	.EntityIndexingInterceptor#onAdd(Object)}
	 * event from where you can
	 * customize the indexing operation.
	 *
	 * @param types optionally restrict the operation to 
	 *	selected types
	 *
	 * @return a new MassIndexer
	 */
	MassIndexer createIndexer(Class<?>... types);

}
\end{lstlisting}