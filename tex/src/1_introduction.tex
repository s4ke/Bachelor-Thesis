\section{Introduction}\label{einleitung}

\subsection{An overview of different database paradigms}

When it comes to persisting data in applications, nowadays there exist a lot of different
paradigms that one has to choose from. Following is a short explanation for the two currently most used ones.

\subsubsection{relational databases}

\subsubsection{NoSQL databases}

\subsection{Object-relational impedance mismatch}

While the NoSQL approach is undeniably rising in popularity, the demand for
relational solutions is still unmatched as it has been used and proven in practice
for many years now.
\\\\
Nowadays, many popular languages like Java, C\#, etc. are object-oriented.
While SQL solutions for querying relational databases exist for these languages, there is a big
discrepancy between the relational and the object-oriented paradigm. \footnote{Wikipedia on Object relational impedance mismatch, see~\cite{wiki_object_mismatch}}
\\\\
This is where Object Relational Mappers (ORM) come into use. They map tables to entities (classes) and
enable users to write queries against classes instead of tables. This is especially useful if used
in big software products as not all programmers have to know the exact details of the underlying database. The database system could even be completely replaced for another with the business logic still being in place.

\subsubsection{JPA}

The first version of the JPA standard was released in May 2006. From then on it rose to probably the most commonly used persistence API for Java. Initially created to standardize only relational database mappers, it since has become the standard for other database concepts like for example NoSQL. The currently newest version of this standard is 2.1.\footnote{Wikipedia on Java Persistence API, see~\cite{wiki_jpa}}
\\\\
Some popular implementations are:
\begin{itemize}
	\item Hibernate ORM
	\item EclipseLink
	\item OpenJPA
\end{itemize}
Using the standardized JPA API has some interesting benefits. For one, the specific JPA implementation can be swapped out. This is particularily important if you are working in a Java EE compliant environment. Java EE itself is a specification for platforms, mostly Web-servers.\footnote{Wikipedia on Java EE, see~\cite{wiki_java_ee}} Many Java EE Web-servers ship with a bundled JPA implementation that they are optimized for. This means that if a user switches servers, he/she is also likely to swap out the JPA implementor. If the user's application is strictly JPA compliant, little to no problems will arise upon such a change.

\subsection{fulltext search}

Conventional relational databases are extremely good at retrieving and querying structured data. But if you want to build a search engine atop your domain model, most RDBMS will only support the SQL-LIKE operator:\\

\lstset{language=sql}
\begin{lstlisting}[frame=htrbl, label={lst:result2}]
SELECT book.id FROM book WHERE book.name LIKE %name%;
\end{lstlisting}
While this might be enough for some applications, this wildcard query doesn't support features a good search engine would need, for example:

\begin{itemize}
	\item fuzzy queries (variations of the original string will get matched, too)
	\item phrase queries (search for a specified phrase)
	\item regular expression queries (matches are determined by a regular expression)
\end{itemize}
There may exist some RDBMS that support similar query-types, but in the context of using a ORM we would then lose the ability to switch databases since we require specific features not every RDBMS supports.
\\\\
Fulltext search engines can be used to complement databases in this regard. They are not intended to be replacing the database but add additional functionality by indexing data that is to be searched obtained by the database. We will now take a look at some of the most popular available options for Java developers.

\subsubsection{Lucene}

\begin{quote}
Apache LuceneTM is a high-performance, full-featured text search engine library written entirely in Java. It is a technology suitable for nearly any application that requires full-text search, especially cross-platform.\footnote{official Lucene website, see~\cite{lucene_apache_org}}
\end{quote}
Lucene serves as the basis for most fulltext search engines written in Java. It has many different utilties and modules aimed at search engine developers. However, it can be used on its own as well.
\\\\
A lucene based application can be structured into two phases:

\paragraph{Indexing}
Before we can search anything with a Lucene based application, the data has to be indexed first. This is done by passing Documents (Lucene's internal data-structure) into an IndexWriter. In these Documents we have to specify tuples (fields) of fieldname and value together with information about how these are to be stored and or indexed. Fieldnames are allowed to be duplicated in this structure.
\\\\
\textcolor{red}{Beispiel f√ºr Lucene usage hier}
\\\\
Lucene is not ACID compliant and does not have a concept similar to entities since everything is stored in a flat key-value structure.

\paragraph{Searching}

\subsubsection{Solr}

\subsubsection{ElasticSearch}

\subsubsection{Hibernate Search}

\subsubsection{Compass (discontinued)}

\subsubsection{compatibility of Hibernate Search with JPA}

\subsection{aims of this thesis}
